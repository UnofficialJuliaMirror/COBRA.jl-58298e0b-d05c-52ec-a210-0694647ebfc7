<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modules and Functions · COBRA.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="COBRA.jl logo"/></a><h1>COBRA.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">COBRA.jl - COnstraint-Based Reconstruction and Analysis</a></li><li><a class="toctext" href="cbg.html">Beginner&#39;s Guide</a></li><li><a class="toctext" href="cobratutorial.html">Tutorial</a></li><li><a class="toctext" href="configuration.html">Configuration</a></li><li class="current"><a class="toctext" href="functions.html">Modules and Functions</a><ul class="internal"><li><a class="toctext" href="#connect.jl-1">connect.jl</a></li><li><a class="toctext" href="#checkSetup.jl-1">checkSetup.jl</a></li><li><a class="toctext" href="#distributedFBA.jl-1">distributedFBA.jl</a></li><li><a class="toctext" href="#load.jl-1">load.jl</a></li><li><a class="toctext" href="#solve.jl-1">solve.jl</a></li><li><a class="toctext" href="#tools.jl-1">tools.jl</a></li></ul></li><li><a class="toctext" href="faq.html">FAQ</a></li><li><a class="toctext" href="contents.html">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="functions.html">Modules and Functions</a></li></ul><a class="edit-page" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/master/docs/src/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Modules and Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><h2><a class="nav-anchor" id="connect.jl-1" href="#connect.jl-1">connect.jl</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="createPool" href="#createPool"><code>createPool</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">createPool(localWorkers, connectSSHWorkers, connectionFile)</code></pre><p>Function used to create a pool of parallel workers that are either local or connected via SSH.</p><p><strong>INPUTS</strong></p><ul><li><p><code>localWorkers</code>:   Number of local workers to connect.                   If <code>connectSSH</code> is <code>true</code>, the number of localWorkers is 1 (host).</p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>connectSSH</code>:     Boolean that indicates whether additional nodes should be connected via SSH.                   (default: <code>false</code>)</p></li><li><p><code>connectionFile</code>  Name of the file with the SSH connection details (default: config/sshCfg.jl in the <code>COBRA</code> package installation folder)</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>workers()</code>:      Array of IDs of the connected workers (local and SSH workers)</p></li><li><p><code>nWorkers</code>:       Total number of connect workers (local and SSH workers)</p></li></ul><p><strong>EXAMPLES</strong></p><p>Minimum working example:</p><pre><code class="language-julia">julia&gt; createPool(localWorkers)</code></pre><p>Local workers and workers on SSH nodes can be connected as follows:</p><pre><code class="language-julia">workersPool, nWorkers = createPool(12, true, &quot;mySSHCfg.jl&quot;)</code></pre><p>which will connect 12 local workers, and all workers defined in <code>mySSHCfg.jl</code>. An example connection file is provided in the <code>config/</code> folder of the <code>COBRA</code> package installation folder.</p><p>See also: <code>workers()</code>, <code>nprocs()</code>, <code>addprocs()</code>, <code>gethostname()</code></p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/connect.jl#L9-L45">source</a></section><h2><a class="nav-anchor" id="checkSetup.jl-1" href="#checkSetup.jl-1">checkSetup.jl</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="checkPackage" href="#checkPackage"><code>checkPackage</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">checkPackage(pkgName)</code></pre><p>Function checks whether a package is installed properly or not and returns a boolean value.</p><p><strong>INPUTS</strong></p><ul><li><p><code>pkgName</code>:        A string that contains the name of the package to be checked</p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>verbose</code>:        Verbose mode:</p><ul><li><p>0: off (quiet)</p></li><li><p>1: on (default)</p></li></ul></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p>(bool):           A boolean that indicates whether a package is installed properly</p></li></ul><p>See also: <code>using</code>, <code>isdir()</code></p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/checkSetup.jl#L9-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="checkSysConfig" href="#checkSysConfig"><code>checkSysConfig</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">checkSysConfig()</code></pre><p>Function evaluates whether the LP solvers of MathProgBase are installed on the system or not and returns a list of these packages. <code>MathProgBase.jl</code> must be installed.</p><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>verbose</code>:        Verbose mode:</p><ul><li><p>0: off (quiet)</p></li><li><p>1: on (default)</p></li></ul></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p>packages:         A list of solver packages installed on the system</p></li></ul><p>See also: <code>MathProgBase</code>, <code>checkPackage()</code></p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/checkSetup.jl#L48-L66">source</a></section><h2><a class="nav-anchor" id="distributedFBA.jl-1" href="#distributedFBA.jl-1">distributedFBA.jl</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="preFBA!" href="#preFBA!"><code>preFBA!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">preFBA!(model, solver, optPercentage, osenseStr, rxnsList)</code></pre><p>Function that solves the original FBA, adds the objective value as a constraint to the stoichiometric matrix of the model, and changes the RHS vector <code>b</code>. Note that the <code>model</code> object is changed.</p><p><strong>INPUTS</strong></p><ul><li><p><code>model</code>:          An <code>::LPproblem</code> object that has been built using the <code>loadModel</code> function.                       All fields of <code>model</code> must be available.</p></li><li><p><code>solver</code>:         A <code>::SolverConfig</code> object that contains a valid <code>handle</code> to the solver</p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>optPercentage</code>:  Only consider solutions that give you at least a certain percentage of the optimal solution (default: 0%)</p></li><li><p><code>osenseStr</code>:      Sets the optimization mode of the original FBA (&quot;max&quot; or &quot;min&quot;, default: &quot;max&quot;)</p></li><li><p><code>rxnsList</code>:       List of reactions to analyze (default: all reactions)</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>objValue</code>:       Optimal objective value of the original FBA problem</p></li><li><p><code>fbaSol</code>:         Solution vector that corresponds to the optimal objective value</p></li></ul><p><strong>EXAMPLES</strong></p><ul><li><p>Minimum working example:</p></li></ul><pre><code class="language-julia">julia&gt; preFBA!(model, solver)</code></pre><ul><li><p>Full input/output example</p></li></ul><pre><code class="language-julia">julia&gt; optSol, fbaSol = preFBA!(model, solver, optPercentage, objective)</code></pre><p>See also: <code>solveCobraLP()</code>, <code>distributedFBA()</code></p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/distributedFBA.jl#L9-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="splitRange" href="#splitRange"><code>splitRange</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">splitRange(model, rxnsList, nWorkers, strategy)</code></pre><p>Function splits a reaction list in blocks for a certain number of workers according to a selected strategy. Generally , <code>splitRange()</code> is called before the FBAs are distributed.</p><p><strong>INPUTS</strong></p><ul><li><p><code>model</code>:          An <code>::LPproblem</code> object that has been built using the <code>loadModel</code> function.                       All fields of <code>model</code> must be available.</p></li><li><p><code>rxnsList</code>:       List of reactions to analyze (default: all reactions)</p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>nWorkers</code>:       Number of workers as initialized using <code>createPool()</code> or similar</p></li><li><p><code>strategy</code>:       Number of the splitting strategy</p><ul><li><p>0: Blind splitting: default random distribution</p></li><li><p>1: Extremal dense-and-sparse splitting: every worker receives dense and sparse reactions, starting from both extremal indices of the sorted column density vector</p></li><li><p>2: Central dense-and-sparse splitting: every worker receives dense and sparse reactions, starting from the beginning and center indices of the sorted column density vector</p></li></ul></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>rxnsKey</code>:        Structure with vector for worker <code>p</code> with start and end indices of each block</p></li></ul><p><strong>EXAMPLES</strong></p><ul><li><p>Minimum working example</p></li></ul><pre><code class="language-julia">julia&gt; splitRange(model, rxnsList, 2)</code></pre><ul><li><p>Selection of the splitting strategy 2 for 4 workers</p></li></ul><pre><code class="language-julia">julia&gt; splitRange(model, rxnsList, 4, 2)</code></pre><p>See also: <code>distributeFBA()</code></p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/distributedFBA.jl#L120-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="loopFBA" href="#loopFBA"><code>loopFBA</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">loopFBA(m, rxnsList, nRxns, rxnsOptMode, iRound, pid, resultsDir, logFiles, onlyFluxes)</code></pre><p>Function used to perform a loop of a series of FBA problems using the CPLEX solver Generally, <code>loopFBA</code> is called in a loop over multiple workers and makes use of the <code>CPLEX.jl</code> module.</p><p><strong>INPUTS</strong></p><ul><li><p><code>m</code>:              A MathProgBase.LinearQuadraticModel object with <code>inner</code> field</p></li><li><p><code>solver</code>:         A <code>::SolverConfig</code> object that contains a valid <code>handle</code>to the solver</p></li><li><p><code>rxnsList</code>:       List of reactions to analyze (default: all reactions)</p></li><li><p><code>nRxns</code>:          Total number of reaction in the model <code>m.inner</code></p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>rxnsOptMode</code>:    List of min/max optimizations to perform:</p><ul><li><p>0: only minimization</p></li><li><p>1: only maximization</p></li><li><p>2: minimization &amp; maximization [default: all reactions are minimized and maximized, i.e. 2+zeros(Int,length(model.rxns))]</p></li></ul></li><li><p><code>iRound</code>:         Index of optimization round</p><ul><li><p>0: minimization</p></li><li><p>1: maximization</p></li></ul></li><li><p><code>pid</code>:            Julia ID of launched process</p></li><li><p><code>resultsDir</code>:     Path to results folder (default is a <code>results</code> folder in the Julia package directory)</p></li><li><p><code>logFiles</code>:       (only available for CPLEX) Boolean to write a solver logfile of each optimization (default: false)</p></li><li><p><code>onlyFluxes</code>:     Save only minFlux and maxFlux if true and will return placeholders for <code>fvamin</code>, <code>fvamax</code>, <code>statussolmin</code>, or <code>statussolmax</code> (applicable for quick checks of large models, default: false)</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>retObj</code>:         Vector with optimal (either <code>min</code> or <code>max</code>) solutions (objective values)</p></li><li><p><code>retFlux</code>:        Array of solution vectors corresponding to the vector with the optimal objective values                   (either <code>min</code> or <code>max</code>)</p></li><li><p><code>retStat</code>:        Vector with the status of the solver of each FBA (default: initialized with <code>-1</code>)</p><ul><li><p>0:   LP problem is infeasible</p></li><li><p>1:   LP problem is optimal</p></li><li><p>2:   LP problem is unbounded</p></li><li><p>3:   Solver for the LP problem has hit a user limit</p></li><li><p>4:   LP problem is infeasible or unbounded</p></li><li><p>5:   LP problem has a non-documented solution status</p></li><li><p>&lt; 0: returned original solution status of solver (only CPLEX supported)</p></li></ul></li></ul><p><strong>EXAMPLES</strong></p><ul><li><p>Minimum working example</p></li></ul><pre><code class="language-julia">julia&gt; loopFBA(m, rxnsList, nRxns)</code></pre><p>See also: <code>distributeFBA()</code>, <code>MathProgBase.HighLevelInterface</code></p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/distributedFBA.jl#L278-L330">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="distributedFBA" href="#distributedFBA"><code>distributedFBA</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">distributedFBA(model, solver, nWorkers, optPercentage, objective, rxnsList, strategy, rxnsOptMode, preFBA, saveChunks, resultsDir, logFiles, onlyFluxes)</code></pre><p>Function to distribute a series of FBA problems across one or more workers that have been initialized using the <code>createPool</code> function (or similar).</p><p><strong>INPUTS</strong></p><ul><li><p><code>model</code>:          An <code>::LPproblem</code> object that has been built using the <code>loadModel</code> function.                       All fields of <code>model</code> must be available.</p></li><li><p><code>solver</code>:         A <code>::SolverConfig</code> object that contains a valid <code>handle</code> to the solver</p></li><li><p><code>nWorkers</code>:       Number of workers as initialized using <code>createPool()</code> or similar</p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>optPercentage</code>:  Only consider solutions that give you at least a certain percentage of the optimal solution (default: 0%).</p></li><li><p><code>objective</code>:      Objective (&quot;min&quot; or &quot;max&quot;) (default: &quot;max&quot;)</p></li><li><p><code>rxnsList</code>:       List of reactions to analyze (default: all reactions)</p></li><li><p><code>strategy</code>:       Number of the splitting strategy</p><ul><li><p>0: Blind splitting: default random distribution</p></li><li><p>1: Extremal dense-and-sparse splitting: every worker receives dense and sparse reactions, starting from both extremal indices of the sorted column density vector</p></li><li><p>2: Central dense-and-sparse splitting: every worker receives dense and sparse reactions, starting from the beginning and center indices of the sorted column density vector</p></li></ul></li><li><p><code>rxnsOptMode</code>:    List of min/max optimizations to perform:</p><ul><li><p>0: only minimization</p></li><li><p>1: only maximization</p></li><li><p>2: minimization &amp; maximization [default: all reactions are minimized and maximized, i.e. <code>2+zeros(Int,length(model.rxns))]</code></p></li></ul></li><li><p><code>preFBA</code>:         Solve the original FBA and add a percentage condition (Boolean variable, default: <code>false</code>). Set to <code>true</code> for flux variability analysis.</p></li><li><p><code>saveChunks</code>:     Save the fluxes of the minimizations and maximizations in individual files on each worker (applicable for large models, default: false)</p></li><li><p><code>resultsDir</code>:     Path to results folder (default is a <code>results</code> folder in the Julia package directory)</p></li><li><p><code>logFiles</code>:       Boolean to write a solver logfile of each optimization (folder <code>resultsDir/logs</code> is automatically created. default: false)</p></li><li><p><code>onlyFluxes</code>:     Save only minFlux and maxFlux if true and will return placeholders for <code>fvamin</code>, <code>fvamax</code>, <code>statussolmin</code>, or <code>statussolmax</code> (applicable for quick checks of large models, default: false)</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>minFlux</code>:        Minimum flux for each reaction</p></li><li><p><code>maxFlux</code>:        Maximum flux for each reaction</p></li><li><p><code>optSol</code>:         Optimal solution of the initial FBA (if <code>preFBA</code> set to <code>true</code>)</p></li><li><p><code>fbaSol</code>:         Solution vector of the initial FBA (if <code>preFBA</code> set to <code>true</code>)</p></li><li><p><code>fvamin</code>:         Array with flux values for the considered reactions (minimization) (if <code>onlyFluxes</code> set to <code>false</code>)     Note: <code>fvamin</code> is saved in individual <code>.mat</code> files when <code>saveChunks</code> is <code>true</code>.</p></li><li><p><code>fvamax</code>:         Array with flux values for the considered reactions (maximization) (if <code>onlyFluxes</code> set to <code>false</code>)     Note: <code>fvamax</code> is saved in individual <code>.mat</code> files when <code>saveChunks</code> is <code>true</code>.</p></li><li><p><code>statussolmin</code>:   Vector of solution status for each reaction (minimization) (if <code>onlyFluxes</code> set to <code>false</code>)</p></li><li><p><code>statussolmax</code>:   Vector of solution status for each reaction (maximization) (if <code>onlyFluxes</code> set to <code>false</code>)</p></li></ul><p><strong>EXAMPLES</strong></p><ul><li><p>Minimum working example</p></li></ul><pre><code class="language-julia">julia&gt; minFlux, maxFlux = distributedFBA(model, solver)</code></pre><ul><li><p>Flux variability analysis with optPercentage = 90% (on 4 workers)</p></li></ul><pre><code class="language-julia">julia&gt; minFlux, maxFlux = distributedFBA(model, solver, nWorkers=4, optPercentage=90.0, preFBA=true)</code></pre><ul><li><p>Full input/output example</p></li></ul><pre><code class="language-julia">julia&gt; minFlux, maxFlux, optSol, fbaSol, fvamin, fvamax, statussolmin, statussolmax = distributedFBA(model, solver, nWorkers=nWorkers, logFiles=true)</code></pre><ul><li><p>Save only the fluxes</p></li></ul><pre><code class="language-julia">julia&gt; minFlux, maxFlux = distributedFBA(model, solver, preFBA=true, saveChunks=false, onlyFluxes=true)</code></pre><ul><li><p>Save flux vectors in files</p></li></ul><pre><code class="language-julia">julia&gt; minFlux, maxFlux, optSol, fbaSol, fvamin, fvamax, statussolmin, statussolmax = distributedFBA(model, solver)</code></pre><p>See also: <code>preFBA!()</code>, <code>splitRange()</code>, <code>buildCobraLP()</code>, <code>loopFBA()</code>, or <code>fetch()</code></p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/distributedFBA.jl#L431-L505">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="printSolSummary" href="#printSolSummary"><code>printSolSummary</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">printSolSummary(testFile, optSol, maxFlux, minFlux, solTime, nWorkers, solverName, strategy, saveChunks)</code></pre><p>Output a solution summary</p><p><strong>INPUTS</strong></p><ul><li><p><code>testFile</code>:       Name of the <code>.mat</code> test file</p></li><li><p><code>optSol</code>:         Optimal solution of the initial FBA</p></li><li><p><code>minFlux</code>:        Minimum flux for each reaction</p></li><li><p><code>maxFlux</code>:        Maximum flux for each reaction</p></li><li><p><code>solTime</code>:        Solution time (in seconds)</p></li><li><p><code>nWorkers</code>:       Number of workers as initialized using <code>createPool()</code> or similar</p></li><li><p><code>solverName</code>:     Name of the solver</p></li><li><p><code>strategy</code>:       Number of the splitting strategy</p><ul><li><p>0: Blind splitting: default random distribution</p></li><li><p>1: Extremal dense-and-sparse splitting: every worker receives dense and sparse reactions, starting from both extremal indices of the sorted column density vector</p></li><li><p>2: Central dense-and-sparse splitting: every worker receives dense and sparse reactions, starting from the beginning and center indices of the sorted column density vector</p></li></ul></li><li><p><code>saveChunks</code>:     Save the fluxes of the minimizations and maximizations in individual files on each worker (applicable for large models)</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p>(Printed summary)</p></li></ul><p>See also: <code>norm()</code>, <code>maximum()</code>, <code>minimum()</code></p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/distributedFBA.jl#L711-L737">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="saveDistributedFBA" href="#saveDistributedFBA"><code>saveDistributedFBA</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">saveDistributedFBA(fileName::String, vars)</code></pre><p>Output a file with all the output variables of <code>distributedFBA()</code> and <code>rxnsList</code></p><p><strong>INPUTS</strong></p><ul><li><p><code>fileName</code>:         Filename of the output</p></li><li><p><code>vars</code>:             List of variables (default: [&quot;minFlux&quot;, &quot;maxFlux&quot;, &quot;optSol&quot;, &quot;fbaSol&quot;, &quot;fvamin&quot;, &quot;fvamax&quot;, &quot;statussolmin&quot;, &quot;statussolmax&quot;, &quot;rxnsList&quot;])</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>.mat</code> file with the specified output variables</p></li></ul><p><strong>EXAMPLES</strong></p><ul><li><p>Minimum working example</p></li></ul><pre><code class="language-julia">julia&gt; saveDistributedFBA(&quot;myResults.mat&quot;)</code></pre><ul><li><p>File location</p></li></ul><pre><code class="language-julia">julia&gt; saveDistributedFBA(&quot;myDirectory/myResults.mat&quot;)</code></pre><ul><li><p>Home location</p></li></ul><pre><code class="language-julia">julia&gt; saveDistributedFBA(ENV[&quot;HOME&quot;]*&quot;/myResults.mat&quot;)</code></pre><ul><li><p>Save minFlux and maxFlux variables</p></li></ul><pre><code class="language-julia">julia&gt; saveDistributedFBA(ENV[&quot;HOME&quot;]*&quot;/myResults.mat&quot;, [&quot;minFlux&quot;, &quot;maxFlux&quot;])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/distributedFBA.jl#L775-L811">source</a></section><h2><a class="nav-anchor" id="load.jl-1" href="#load.jl-1">load.jl</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPproblem" href="#LPproblem"><code>LPproblem</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LPproblem(S, b, c, lb, ub, osense, csense, rxns, mets)</code></pre><p>General type for storing an LP problem which contains the following fields:</p><ul><li><p><code>S</code>:              LHS matrix (m x n)</p></li><li><p><code>b</code>:              RHS vector (m x 1)</p></li><li><p><code>c</code>:              Objective coefficient vector (n x 1)</p></li><li><p><code>lb</code>:             Lower bound vector (n x 1)</p></li><li><p><code>ub</code>:             Upper bound vector (n x 1)</p></li><li><p><code>osense</code>:         Objective sense (scalar; -1 ~ &quot;max&quot;, +1 ~ &quot;min&quot;)</p></li><li><p><code>csense</code>:         Constraint senses (m x 1, &#39;E&#39; or &#39;=&#39;, &#39;G&#39; or &#39;&gt;&#39;, &#39;L&#39; ~ &#39;&lt;&#39;)</p></li><li><p><code>solver</code>:         A <code>::SolverConfig</code> object that contains a valid <code>handle</code> to the solver</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/load.jl#L9-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="loadModel" href="#loadModel"><code>loadModel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">loadModel(fileName, matrixAS, modelName, modelFields)</code></pre><p>Function used to load a COBRA model from an existing .mat file</p><p><strong>INPUTS</strong></p><ul><li><p><code>filename</code>:       Name of the <code>.mat</code> file that contains the model structure</p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>matrixAS</code>:       String to distinguish the name of stoichiometric matrix (&quot;S&quot; or &quot;A&quot;, default: &quot;S&quot;)</p></li><li><p><code>modelName</code>:      String with the name of the model structure (default: &quot;model&quot;)</p></li><li><p><code>modelFields</code>:    Array with strings of fields of the model structure (default: [&quot;ub&quot;, &quot;lb&quot;, &quot;osense&quot;, &quot;c&quot;, &quot;b&quot;, &quot;csense&quot;, &quot;rxns&quot;, &quot;mets&quot;])</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>LPproblem()</code>     <code>:LPproblem</code> object with filled fields from <code>.mat</code> file</p></li></ul><p><strong>Examples</strong></p><ul><li><p>Minimum working example</p></li></ul><pre><code class="language-julia">julia&gt; loadModel(&quot;myModel.mat&quot;)</code></pre><ul><li><p>Full input/output example</p></li></ul><pre><code class="language-julia">julia&gt; model = loadModel(&quot;myModel.mat&quot;, &quot;A&quot;, &quot;myModelName&quot;, [&quot;ub&quot;,&quot;lb&quot;,&quot;osense&quot;,&quot;c&quot;,&quot;b&quot;,&quot;csense&quot;,&quot;rxns&quot;,&quot;mets&quot;]);</code></pre><p><strong>Notes</strong></p><ul><li><p><code>osense</code> is set to &quot;max&quot; (osense = -1) by default</p></li><li><p>All entries of <code>A</code>, <code>b</code>, <code>c</code>, <code>lb</code>, <code>ub</code> are of type float</p></li></ul><p>See also: <code>MAT.jl</code>, <code>matopen()</code>, <code>matread()</code></p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/load.jl#L38-L75">source</a></section><h2><a class="nav-anchor" id="solve.jl-1" href="#solve.jl-1">solve.jl</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverConfig" href="#SolverConfig"><code>SolverConfig</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SolverConfig(name, handle)</code></pre><p>Definition of a common solver type, which inclues the name of the solver and other parameters</p><ul><li><p><code>name</code>:           Name of the solver (alias)</p></li><li><p><code>handle</code>:         Solver handle used to refer to the solver</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/solve.jl#L9-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="buildCobraLP" href="#buildCobraLP"><code>buildCobraLP</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">buildCobraLP(model, solver)</code></pre><p>Build a model by interfacing directly with the CPLEX solver</p><p><strong>INPUTS</strong></p><ul><li><p><code>model</code>:          An <code>::LPproblem</code> object that has been built using the <code>loadModel</code> function.                       All fields of <code>model</code> must be available.</p></li><li><p><code>solver</code>:         A <code>::SolverConfig</code> object that contains a valid <code>handle</code>to the solver</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>m</code>:              A MathProgBase.LinearQuadraticModel object with <code>inner</code> field</p></li></ul><p><strong>EXAMPLES</strong></p><pre><code class="language-julia">julia&gt; m = buildCobraLP(model, solver)</code></pre><p>See also: <code>MathProgBase.LinearQuadraticModel()</code>, <code>MathProgBase.HighLevelInterface.buildlp()</code></p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/solve.jl#L25-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="changeCobraSolver" href="#changeCobraSolver"><code>changeCobraSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">changeCobraSolver(name, params)</code></pre><p>Function used to change the solver and include the respective solver interfaces</p><p><strong>INPUT</strong></p><ul><li><p><code>name</code>:           Name of the solver (alias)</p></li></ul><p><strong>OPTIONAL INPUT</strong></p><ul><li><p><code>params</code>:         Solver parameters as a row vector with tuples</p></li></ul><p><strong>OUTPUT</strong></p><ul><li><p><code>solver</code>:         Solver object with a <code>handle</code> field</p></li></ul><p><strong>EXAMPLES</strong></p><p>Minimum working example (for the CPLEX solver)</p><pre><code class="language-julia">julia&gt; changeCobraSolver(&quot;CPLEX&quot;, cpxControl)</code></pre><p>See also: <code>MathProgBase.jl</code></p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/solve.jl#L67-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="solveCobraLP" href="#solveCobraLP"><code>solveCobraLP</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">solveCobraLP(model, solver)</code></pre><p>Function used to solve a linear program (LP) with a specified solver. LP problem must have the form:</p><pre><code class="language-none">                                  max/min cᵀv
                                   s.t.  Av = b
                                        l ⩽ v ⩽ u</code></pre><p><strong>INPUTS</strong></p><ul><li><p><code>model</code>:          An <code>::LPproblem</code> object that has been built using the <code>loadModel</code> function.                       All fields of <code>model</code> must be available.</p></li><li><p><code>solver</code>:         A <code>::SolverConfig</code> object that contains a valid <code>handle</code>to the solver</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>solutionLP</code>:     Solution object of type <code>LPproblem</code></p></li></ul><p><strong>EXAMPLES</strong></p><p>Minimum working example</p><pre><code class="language-julia">julia&gt; solveCobraLP(model, solver)</code></pre><p>See also: <code>MathProgBase.linprog()</code>,</p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/solve.jl#L158-L186">source</a></section><h2><a class="nav-anchor" id="tools.jl-1" href="#tools.jl-1">tools.jl</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="findRxnIDS" href="#findRxnIDS"><code>findRxnIDS</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">findRxnIDS(model, rxnsList)</code></pre><p>Function that returns a vector of reaction IDs that correspond to an input list of reaction names.</p><p><strong>INPUTS</strong></p><ul><li><p><code>model</code>:          An <code>::LPproblem</code> object that has been built using the <code>loadModel</code> function.                       All fields of <code>model</code> must be available.</p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>rxnsList</code>:       List of reaction names (default: all reactions in the model)</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>rxnIDs</code>:       	Vector with the reaction IDs that correspond to the reaction names in <code>rxnsList</code></p></li></ul><p><strong>EXAMPLES</strong></p><ul><li><p>Minimum working example:</p></li></ul><pre><code class="language-julia">julia&gt; findRxnIDS(model)</code></pre><ul><li><p>Full input/output example</p></li></ul><pre><code class="language-julia">julia&gt; rxnIDs, rxnIDsNE = findRxnIDS(model, rxnsList)</code></pre><ul><li><p>Full input/output example</p></li></ul><pre><code class="language-julia">julia&gt; rxnIDs, rxnIDsNE = findRxnIDS(model, [&quot;reactionName1&quot;, &quot;reactionName2&quot;])</code></pre><p>See also: <code>loadModel()</code>, <code>distributedFBA()</code></p></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/tools.jl#L9-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="convertUnitRange" href="#convertUnitRange"><code>convertUnitRange</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">convertUnitRange(vect)</code></pre><p>Converts a unit range vector to an array type vector. If the vector is not of UnitRange{Int64} type, the same vector is returned.</p><p><strong>INPUTS</strong></p><ul><li><p><code>vect</code>:         Any vector (UnitRange{Int64} will be converted to Array{Int64})</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>retVect</code>       Converted vector (if type of input vector is UnitRange{Int64})</p></li></ul><p><strong>EXAMPLES</strong></p><ul><li><p>Minimum working example</p></li></ul><pre><code class="language-julia">julia&gt; a = 1:4
1:4

julia&gt; convertUnitRange(a)
4-element Array{Int64,1}:
  1
  2
  3
  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/github.com/opencobra/COBRA.jl.git/blob/3b778350c874f3bdc8a4a399b0c4cb129d11f2f0/src/tools.jl#L96-L125">source</a></section><footer><hr/><a class="previous" href="configuration.html"><span class="direction">Previous</span><span class="title">Configuration</span></a><a class="next" href="faq.html"><span class="direction">Next</span><span class="title">FAQ</span></a></footer></article></body></html>
